use std::{io, mem, panic, slice};

use phenix_runtime::Encodable;

mod generated;

pub use generated::*;
pub use manual::*;

// Put these into a module so that the order of functions generated by cbindgen
// is as desired.
mod manual {
    use std::{ffi, slice};

    use super::*;

    #[no_mangle]
    pub extern "C" fn phenix_runtime_string_encode(
        value: *const libc::c_char,
        stream: *mut libc::FILE,
    ) -> libc::c_int {
        #![allow(clippy::not_unsafe_ptr_arg_deref)]
        let value = unsafe { ffi::CStr::from_ptr(value) };
        let value = value.to_string_lossy();
        crate::call_encode(&&*value, stream)
    }

    #[no_mangle]
    pub extern "C" fn phenix_runtime_string_encode_many(
        values: *const *const libc::c_char,
        n: usize,
        stream: *mut libc::FILE,
    ) -> libc::c_int {
        crate::wrap(|| {
            for value in unsafe { slice::from_raw_parts(values, n) }.iter().copied() {
                let value = unsafe { ffi::CStr::from_ptr(value) };
                let value = value.to_string_lossy();
                (&*value).encode(&mut RawWriter::wrap(stream))?
            }

            Ok(())
        })
    }

    #[no_mangle]
    pub extern "C" fn phenix_runtime_encode_discriminant(
        n: usize,
        stream: *mut libc::FILE,
    ) -> libc::c_int {
        crate::wrap(|| {
            phenix_runtime::base::utils::encode_discriminant(n, &mut RawWriter::wrap(stream))
        })
    }

    #[no_mangle]
    pub extern "C" fn phenix_runtime_encode_discriminant_relaxed(
        n: usize,
        stream: *mut libc::FILE,
    ) -> libc::c_int {
        crate::wrap(|| {
            phenix_runtime::base::utils::encode_discriminant_relaxed(
                n,
                &mut RawWriter::wrap(stream),
            )
        })
    }
}

fn call_encode<T: Encodable + panic::RefUnwindSafe>(
    value: &T,
    stream: *mut libc::FILE,
) -> libc::c_int {
    wrap(|| value.encode(&mut RawWriter::wrap(stream)))
}

fn call_encode_many<T: Encodable + panic::RefUnwindSafe>(
    values: *const T,
    n: usize,
    stream: *mut libc::FILE,
) -> libc::c_int {
    wrap(|| {
        T::encode_many(
            unsafe { slice::from_raw_parts(values, n) },
            &mut RawWriter::wrap(stream),
        )
    })
}

fn wrap<F>(f: F) -> libc::c_int
where
    F: FnOnce() -> io::Result<()> + panic::UnwindSafe,
{
    match panic::catch_unwind(f) {
        Ok(Ok(_)) => 0,
        Ok(Err(error)) => error.raw_os_error().unwrap_or(1),
        Err(_) => 1,
    }
}

struct RawWriter {
    stream: *mut libc::FILE,
}

impl RawWriter {
    fn wrap(stream: *mut libc::FILE) -> Self {
        Self { stream }
    }
}

impl io::Write for RawWriter {
    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
        unsafe {
            if libc::fwrite(
                buf.as_ptr().cast(),
                mem::size_of::<u8>(),
                buf.len(),
                self.stream,
            ) != buf.len()
            {
                return Err(io::Error::from_raw_os_error(libc::ferror(self.stream)));
            }

            Ok(buf.len())
        }
    }

    fn flush(&mut self) -> io::Result<()> {
        let ret = unsafe { libc::fflush(self.stream) };
        if ret == 0 {
            Ok(())
        } else {
            Err(io::Error::from_raw_os_error(ret))
        }
    }
}
